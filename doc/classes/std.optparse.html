<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>stdlib 41.0.0 Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>stdlib 41.0.0</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Objects">Objects</a></li>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Tables">Tables</a></li>
<li><a href="#Methods">Methods</a></li>
</ul>


<h2>Classes</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../classes/std.container.html">std.container</a></li>
  <li><a href="../classes/std.list.html">std.list</a></li>
  <li><a href="../classes/std.object.html">std.object</a></li>
  <li><strong>std.optparse</strong></li>
  <li><a href="../classes/std.set.html">std.set</a></li>
  <li><a href="../classes/std.strbuf.html">std.strbuf</a></li>
  <li><a href="../classes/std.tree.html">std.tree</a></li>
</ul>
<h2>Modules</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../modules/std.html">std</a></li>
  <li><a href="../modules/std.debug.html">std.debug</a></li>
  <li><a href="../modules/std.functional.html">std.functional</a></li>
  <li><a href="../modules/std.io.html">std.io</a></li>
  <li><a href="../modules/std.math.html">std.math</a></li>
  <li><a href="../modules/std.operator.html">std.operator</a></li>
  <li><a href="../modules/std.package.html">std.package</a></li>
  <li><a href="../modules/std.strict.html">std.strict</a></li>
  <li><a href="../modules/std.string.html">std.string</a></li>
  <li><a href="../modules/std.table.html">std.table</a></li>
</ul>

</div>

<div id="content">

<h1>Class <code>std.optparse</code></h1>
<p>Parse and process command line options.</p>
<p>


<h2> Prototype Chain</h2>


<pre>
<span class="global">table</span>
 <span class="backtick">`-&gt; Object
      `</span>-&gt; OptionParser
</pre>

</p>


<h2><a href="#Objects">Objects</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#std.optparse.OptionParser">std.optparse.OptionParser</a></td>
	<td class="summary">OptionParser prototype object.</td>
	</tr>
</table>
<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#std.optparse.OptionParser_Init">std.optparse.OptionParser_Init (spec)</a></td>
	<td class="summary">Signature for initialising a custom OptionParser.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.optparse.boolean">std.optparse.boolean (opt[, optarg="1"])</a></td>
	<td class="summary">Return a Lua boolean equivalent of various <em>optarg</em> strings.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.optparse.file">std.optparse.file (opt, optarg)</a></td>
	<td class="summary">Report an option parse error unless <em>optarg</em> names an
 existing file.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.optparse.finished">std.optparse.finished (arglist, i)</a></td>
	<td class="summary">Finish option processing</p>

<p> This is the handler automatically assigned to the option written as
 <code>--</code> in the <a href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser</a> spec argument.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.optparse.flag">std.optparse.flag (arglist, i[, value])</a></td>
	<td class="summary">Option at <code>arglist[i]</code> is a boolean switch.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.optparse.help">std.optparse.help ()</a></td>
	<td class="summary">Option should display help text, then exit.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.optparse.opterr">std.optparse.opterr (msg)</a></td>
	<td class="summary">Report an option parse error, then exit with status 2.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.optparse.optional">std.optparse.optional (arglist, i[, value=true])</a></td>
	<td class="summary">Option at <code>arglist[i]</code> can take an argument.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.optparse.required">std.optparse.required (arglist, i[, value])</a></td>
	<td class="summary">Option at <code>arglist[i}</code> requires an argument.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.optparse.version">std.optparse.version ()</a></td>
	<td class="summary">Option should display version text, then exit.</td>
	</tr>
</table>
<h2><a href="#Tables">Tables</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#std.optparse.boolvals">std.optparse.boolvals</a></td>
	<td class="summary">Map various option strings to equivalent Lua boolean values.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.optparse.opts">std.optparse.opts</a></td>
	<td class="summary">Parsed options table, with a key for each encountered option, each
 with value set by that option's <a href="../classes/std.optparse.html#std.optparse:on_handler">on_handler</a>.</td>
	</tr>
</table>
<h2><a href="#Methods">Methods</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#std.optparse:on">std.optparse:on (name, handler, value)</a></td>
	<td class="summary">Add an option handler.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.optparse:on_handler">std.optparse:on_handler (arglist, i[, value=nil])</a></td>
	<td class="summary">Function signature of an option handler for <a href="../classes/std.optparse.html#std.optparse:on">on</a>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.optparse:parse">std.optparse:parse (arglist[, defaults])</a></td>
	<td class="summary">Parse an argument list.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Objects"></a>Objects</h2>

    <dl class="function">
    <dt>
    <a name = "std.optparse.OptionParser"></a>
    <strong>std.optparse.OptionParser</strong>
    </dt>
    <dd>
    OptionParser prototype object. </p>

<p> Most often, after instantiating an <a href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser</a>, everything else
 is handled automatically.</p>

<p> Then, calling <code>parser:parse</code> as shown below saves unparsed arguments
 into <code>_G.arg</code> (usually filenames or similar), and <code>_G.opts</code> will be a
 table of successfully parsed option values. The keys into this table
 are the long-options with leading hyphens stripped, and non-word
 characters turned to <code>_</code>.  For example if <code>--another-long</code> had been
 found in the initial <code>_G.arg</code>, then <code>_G.opts</code> will have a key named
 <code>another_long</code>, with an appropriate value.  If there is no long
 option name, then the short option is used, i.e. <code>_G.opts.b</code> will be
 set.</p>

<p> The values saved against those keys are controlled by the option
 handler, usually just <code>true</code> or the option argument string as
 appropriate.


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">_init</span>
            <span class="types"><a class="type" href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser_Init</a></span>
         initialisation function
        </li>
        <li><span class="parameter">program</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         the first word following "Usage:" from <em>spec</em>
        </li>
        <li><span class="parameter">version</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         the last white-space delimited word on the first line
   of text from <em>spec</em>
        </li>
        <li><span class="parameter">versiontext</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         everything preceding "Usage:" from <em>spec</em>, and
   which will be displayed by the <a href="../classes/std.optparse.html#std.optparse.version">version</a> <a href="../classes/std.optparse.html#std.optparse:on_handler">on_handler</a>
        </li>
        <li><span class="parameter">helptext</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         everything including and following "Usage:" from
   <em>spec</em> string and which will be displayed by the <a href="../classes/std.optparse.html#std.optparse.help">help</a>
   <a href="../classes/std.optparse.html#std.optparse:on_handler">on_handler</a>
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">
 <span class="keyword">local</span> std = <span class="global">require</span> <span class="string">"std"</span>

 <span class="keyword">local</span> optparser = std.optparse <span class="string">[[
 any text VERSION
 Additional lines of text to show when the --version
 option is passed.

 Several lines or paragraphs are permitted.

 Usage: PROGNAME

 Banner text.

 Optional long description text to show when the --help
 option is passed.

 Several lines or paragraphs of long description are permitted.

 Options:

   -b                       a short option with no long option
       --long               a long option with no short option
       --another-long       a long option with internal hypen
   -v, --verbose            a combined short and long option
   -n, --dryrun, --dry-run  several spellings of the same option
   -u, --name=USER          require an argument
   -o, --output=[FILE]      accept an optional argument
       --version            display version information, then exit
       --help               display this help, then exit

 Footer text.  Several lines or paragraphs are permitted.

 Please report bugs at bug-list@yourhost.com
 ]]</span>

 <span class="comment">-- Note that <a href="../modules/std.io.html#die">std.io.die</a> and <a href="../modules/std.io.html#warn">std.io.warn</a> will only prefix messages
</span> <span class="comment">-- with `parser.program` if the parser options are assigned back to
</span> <span class="comment">-- `_G.opts`:
</span> _G.arg, _G.opts = optparser:parse (_G.arg)</pre>
    </ul>

</dd>
</dl>
    <h2><a name="Functions"></a>Functions</h2>
    Methods
    <dl class="function">
    <dt>
    <a name = "std.optparse.OptionParser_Init"></a>
    <strong>std.optparse.OptionParser_Init (spec)</strong>
    </dt>
    <dd>
    Signature for initialising a custom OptionParser. </p>

<p> Read the documented options from <em>spec</em> and return custom parser that
 can be used for parsing the options described in <em>spec</em> from a run-time
 argument list.  Options in <em>spec</em> are recognised as lines that begin
 with at least two spaces, followed by a hyphen.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">spec</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         option parsing specification
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser</a></span>
        a parser for options described by <em>spec</em>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">customparser = std.optparse (optparse_spec)</pre>
    </ul>

</dd>
    <dt>
    <a name = "std.optparse.boolean"></a>
    <strong>std.optparse.boolean (opt[, optarg="1"])</strong>
    </dt>
    <dd>
    Return a Lua boolean equivalent of various <em>optarg</em> strings.
 Report an option parse error if <em>optarg</em> is not recognised.</p>

<p> Pass this as the <code>value</code> function to <a href="../classes/std.optparse.html#std.optparse:on">on</a> when you want various
 "truthy" or "falsey" option arguments to be coerced to a Lua <code>true</code>
 or <code>false</code> respectively in the options table.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">opt</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         option name
        </li>
        <li><span class="parameter">optarg</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         option argument, must be a key in <a href="../classes/std.optparse.html#std.optparse.boolvals">boolvals</a>
         (<em>default</em> "1")
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">bool</span></span>
        <code>true</code> or <code>false</code>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">parser:on (<span class="string">"--enable-nls"</span>, parser.optional, parser.boolean)</pre>
    </ul>

</dd>
    <dt>
    <a name = "std.optparse.file"></a>
    <strong>std.optparse.file (opt, optarg)</strong>
    </dt>
    <dd>
    Report an option parse error unless <em>optarg</em> names an
 existing file. </p>

<p> Pass this as the <code>value</code> function to <a href="../classes/std.optparse.html#std.optparse:on">on</a> when you want to accept
 only option arguments that name an existing file.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">opt</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         option name
        </li>
        <li><span class="parameter">optarg</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         option argument, must be an existing file
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        <em>optarg</em>
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">parser:on (<span class="string">"--config-file"</span>, parser.required, parser.file)</pre>
    </ul>

</dd>
    <dt>
    <a name = "std.optparse.finished"></a>
    <strong>std.optparse.finished (arglist, i)</strong>
    </dt>
    <dd>
    Finish option processing</p>

<p> This is the handler automatically assigned to the option written as
 <code>--</code> in the <a href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser</a> spec argument.   You can also pass it as
 the <code>handler</code> argument to <a href="../classes/std.optparse.html#std.optparse:on">on</a> if you want to manually add an end
 of options marker without writing it in the <a href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser</a> spec.</p>

<p> This handler tells the parser to stop processing arguments, so that
 anything after it will be an argument even if it otherwise looks
 like an option.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">arglist</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         list of arguments
        </li>
        <li><span class="parameter">i</span>
            <span class="types"><span class="type">int</span></span>
         index of last processed element of <code>arglist</code>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">int</span></span>
        index of next element of <code>arglist</code> to process
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">parser:on (<span class="string">"--"</span>, parser.finished)</pre>
    </ul>

</dd>
    <dt>
    <a name = "std.optparse.flag"></a>
    <strong>std.optparse.flag (arglist, i[, value])</strong>
    </dt>
    <dd>
    Option at <code>arglist[i]</code> is a boolean switch. </p>

<p> This is the handler automatically assigned to options that have
 <code>--long-opt</code> or <code>-x</code> style specifications in the <a href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser</a> spec
 argument. You can also pass it as the <code>handler</code> argument to <a href="../classes/std.optparse.html#std.optparse:on">on</a> for
 options you want to add manually without putting them in the
 <a href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser</a> spec.</p>

<p> Beware that, <em>unlike</em> <a href="../classes/std.optparse.html#std.optparse.required">required</a>, this handler will store multiple
 occurrences of a command-line option as a table <strong>only</strong> when given a
 <code>value</code> function.  Automatically assigned handlers do not do this, so
 the option will simply be <code>true</code> if the option was given one or more
 times on the command-line.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">arglist</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         list of arguments
        </li>
        <li><span class="parameter">i</span>
            <span class="types"><span class="type">int</span></span>
         index of last processed element of <em>arglist</em>
        </li>
        <li><span class="parameter">value</span>
         either a function to process the option argument,
   or a value to store when this flag is encountered
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">int</span></span>
        index of next element of <em>arglist</em> to process
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">parser:on ({<span class="string">"--long-opt"</span>, <span class="string">"-x"</span>}, parser.flag)</pre>
    </ul>

</dd>
    <dt>
    <a name = "std.optparse.help"></a>
    <strong>std.optparse.help ()</strong>
    </dt>
    <dd>
    Option should display help text, then exit. </p>

<p> This is the handler automatically assigned tooptions that have
 <code>--help</code> in the specification, e.g. <code>-h, -?, --help</code>.






    <h3>Usage:</h3>
    <ul>
        <pre class="example">parser:on (<span class="string">"-?"</span>, parser.version)</pre>
    </ul>

</dd>
    <dt>
    <a name = "std.optparse.opterr"></a>
    <strong>std.optparse.opterr (msg)</strong>
    </dt>
    <dd>
    Report an option parse error, then exit with status 2. </p>

<p> Use this in your custom option handlers for consistency with the
 error output from built-in <a href="../classes/std.optparse.html#">std.optparse</a> error messages.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">msg</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         error message
        </li>
    </ul>





</dd>
    <dt>
    <a name = "std.optparse.optional"></a>
    <strong>std.optparse.optional (arglist, i[, value=true])</strong>
    </dt>
    <dd>
    Option at <code>arglist[i]</code> can take an argument.
 Argument is accepted only if there is a following entry that does not
 begin with a '-'.</p>

<p> This is the handler automatically assigned to options that have
 <code>--opt=[ARG]</code> style specifications in the <a href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser</a> spec
 argument.  You can also pass it as the <code>handler</code> argument to <a href="../classes/std.optparse.html#std.optparse:on">on</a> for
 options you want to add manually without putting them in the
 <a href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser</a> spec.</p>

<p> Like <a href="../classes/std.optparse.html#std.optparse.required">required</a>, this handler will store multiple occurrences of a
 command-line option.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">arglist</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         list of arguments
        </li>
        <li><span class="parameter">i</span>
            <span class="types"><span class="type">int</span></span>
         index of last processed element of <em>arglist</em>
        </li>
        <li><span class="parameter">value</span>
         either a function to process the option
   argument, or a default value if encountered without an optarg
         (<em>default</em> true)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">int</span></span>
        index of next element of <em>arglist</em> to process
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">parser:on (<span class="string">"--enable-nls"</span>, parser.option, parser.boolean)</pre>
    </ul>

</dd>
    <dt>
    <a name = "std.optparse.required"></a>
    <strong>std.optparse.required (arglist, i[, value])</strong>
    </dt>
    <dd>

<p>Option at <code>arglist[i}</code> requires an argument. </p>

<p> This is the handler automatically assigned to options that have
 <code>--opt=ARG</code> style specifications in the <a href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser</a> spec argument.
 You can also pass it as the <code>handler</code> argument to <a href="../classes/std.optparse.html#std.optparse:on">on</a> for options
 you want to add manually without putting them in the <a href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser</a>
 spec.</p>

<p> Normally the value stored in the <code>opt</code> table by this handler will be
 the string given as the argument to that option on the command line.
 However, if the option is given on the command-line multiple times,
 <code>opt["name"]</code> will end up with all those arguments stored in the
 array part of a table:</p>

<pre><code> $ cat ./prog
 ...
 parser:on ({"-e", "-exec"}, required)
 _G.arg, _G.opt = parser:parse (_G.arg)
 print std.string.tostring (_G.opt.exec)
 ...
 $ ./prog -e '(foo bar)' -e '(foo baz)' -- qux
 {1=(foo bar),2=(foo baz)}
</code></pre>



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">arglist</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         list of arguments
        </li>
        <li><span class="parameter">i</span>
            <span class="types"><span class="type">int</span></span>
         index of last processed element of <em>arglist</em>
        </li>
        <li><span class="parameter">value</span>
         either a function to process the option argument,
   or a forced value to replace the user's option argument.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">int</span></span>
        index of next element of <em>arglist</em> to process
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">parser:on ({<span class="string">"-o"</span>, <span class="string">"--output"</span>}, parser.required)</pre>
    </ul>

</dd>
    <dt>
    <a name = "std.optparse.version"></a>
    <strong>std.optparse.version ()</strong>
    </dt>
    <dd>
    Option should display version text, then exit. </p>

<p> This is the handler automatically assigned tooptions that have
 <code>--version</code> in the specification, e.g. <code>-V, --version</code>.






    <h3>Usage:</h3>
    <ul>
        <pre class="example">parser:on (<span class="string">"-V"</span>, parser.version)</pre>
    </ul>

</dd>
</dl>
    <h2><a name="Tables"></a>Tables</h2>

    <dl class="function">
    <dt>
    <a name = "std.optparse.boolvals"></a>
    <strong>std.optparse.boolvals</strong>
    </dt>
    <dd>
    Map various option strings to equivalent Lua boolean values.


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">false</span>
         false
        </li>
        <li><span class="parameter">0</span>
         false
        </li>
        <li><span class="parameter">no</span>
         false
        </li>
        <li><span class="parameter">n</span>
         false
        </li>
        <li><span class="parameter">true</span>
         true
        </li>
        <li><span class="parameter">1</span>
         true
        </li>
        <li><span class="parameter">yes</span>
         true
        </li>
        <li><span class="parameter">y</span>
         true
        </li>
    </ul>





</dd>
    <dt>
    <a name = "std.optparse.opts"></a>
    <strong>std.optparse.opts</strong>
    </dt>
    <dd>
    Parsed options table, with a key for each encountered option, each
 with value set by that option's <a href="../classes/std.optparse.html#std.optparse:on_handler">on_handler</a>.   Where an option
 has one or more long-options specified, the key will be the first
 one of those with leading hyphens stripped and non-alphanumeric
 characters replaced with underscores.  For options that can only be
 specified by a short option, the key will be the letter of the first
 of the specified short options:</p>

<pre><code> {"-e", "--eval-file"} =&gt; opts.eval_file
 {"-n", "--dryrun", "--dry-run"} =&gt; opts.dryrun
 {"-t", "-T"} =&gt; opts.t
</code></pre>

<p> Generally there will be one key for each previously specified
 option (either automatically assigned by <a href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser</a> or
 added manually with <a href="../classes/std.optparse.html#std.optparse:on">on</a>) containing the value(s) assigned by the
 associated <a href="../classes/std.optparse.html#std.optparse:on_handler">on_handler</a>.  For automatically assigned handlers,
 that means <code>true</code> for straight-forward flags and
 optional-argument options for which no argument was given; or else
 the string value of the argument passed with an option given only
 once; or a table of string values of the same for arguments given
 multiple times.</p>

<pre><code> ./prog -x -n -x =&gt; opts = { x = true, dryrun = true }
 ./prog -e '(foo bar)' -e '(foo baz)'
     =&gt; opts = {eval_file = {"(foo bar)", "(foo baz)"} }
</code></pre>

<p> If you write your own handlers, or otherwise specify custom
 handling of options with <a href="../classes/std.optparse.html#std.optparse:on">on</a>, then whatever value those handlers
 return will be assigned to the respective keys in <code>opts</code>.







</dd>
</dl>
    <h2><a name="Methods"></a>Methods</h2>

    <dl class="function">
    <dt>
    <a name = "std.optparse:on"></a>
    <strong>std.optparse:on (name, handler, value)</strong>
    </dt>
    <dd>
    Add an option handler. </p>

<p> When the automatically assigned option handlers don't do everything
 you require, or when you don't want to put an option into the
 <a href="../classes/std.optparse.html#std.optparse.OptionParser">OptionParser</a> <code>spec</code> argument, use this function to specify custom
 behaviour.  If you write the option into the <code>spec</code> argument anyway,
 calling this function will replace the automatically assigned handler
 with your own.</p>

<p> When writing your own handlers for <a href="../classes/std.optparse.html#std.optparse:on">std.optparse:on</a>, you only need
 to deal with normalised arguments, because combined short arguments
 (<code>-xyz</code>), equals separators to long options (<code>--long=ARG</code>) are fully
 expanded before any handler is called.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">name</span>
            <span class="types"><a class="type" href="../classes/std.optparse.html#std.optparse.opts">opts</a></span>
         of the option, or list of option names
        </li>
        <li><span class="parameter">handler</span>
            <span class="types"><a class="type" href="../classes/std.optparse.html#std.optparse:on">on_handler</a></span>
         function to call when any of <em>opts</em> is
   encountered
        </li>
        <li><span class="parameter">value</span>
         additional value passed to <a href="../classes/std.optparse.html#std.optparse:on_handler">on_handler</a>
        </li>
    </ul>




    <h3>Usage:</h3>
    <ul>
        <pre class="example">
 <span class="comment">-- Don't process any arguments after `--`
</span> parser:on (<span class="string">'--'</span>, parser.finished)</pre>
    </ul>

</dd>
    <dt>
    <a name = "std.optparse:on_handler"></a>
    <strong>std.optparse:on_handler (arglist, i[, value=nil])</strong>
    </dt>
    <dd>
    Function signature of an option handler for <a href="../classes/std.optparse.html#std.optparse:on">on</a>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">arglist</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         list of arguments
        </li>
        <li><span class="parameter">i</span>
            <span class="types"><span class="type">int</span></span>
         index of last processed element of <em>arglist</em>
        </li>
        <li><span class="parameter">value</span>
         additional <code>value</code> registered with <a href="../classes/std.optparse.html#std.optparse:on">on</a>
         (<em>default</em> nil)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">int</span></span>
        index of next element of <em>arglist</em> to process
    </ol>




</dd>
    <dt>
    <a name = "std.optparse:parse"></a>
    <strong>std.optparse:parse (arglist[, defaults])</strong>
    </dt>
    <dd>
    Parse an argument list.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">arglist</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         list of arguments
        </li>
        <li><span class="parameter">defaults</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         table of default option values
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
           <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
        a list of unrecognised <em>arglist</em> elements</li>
        <li>
           <span class="types"><a class="type" href="../classes/std.optparse.html#std.optparse.opts">opts</a></span>
        parsing results</li>
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2015-01-03 18:38:43 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
