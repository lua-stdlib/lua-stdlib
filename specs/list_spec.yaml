before:
  this_module = "std.list"
  M           = require (this_module)
  List        = M.prototype
  l           = List {"foo", "bar", "baz"}

  setdebug { deprecate = false }

  deprecate_on = bind (deprecation, {"nil", this_module})
  deprecate_off = bind (deprecation, {false, this_module})


specify std.list:
- context when required:
  - context by name:
    - it does not perturb the global namespace:
        expect (show_apis {added_to="_G", by="std.list"}).to_equal {}
  - context via the std module:
    - it does not perturb the global namespace:
        expect (show_apis {added_to="_G", by="std"}).to_equal {}


- describe construction:
  - context from List clone method:
    - it constructs a new list:
        l = List:clone {}
        expect (l).not_to_be (List)
        expect (objtype (l)).to_be "List"
    - it reuses the List metatable:
        l, m = List:clone {"l"}, List:clone {"m"}
        expect (getmetatable (l)).to_be (getmetatable (m))
    - it initialises List with constructor parameters:
        m = List:clone {"foo", "bar", "baz"}
        expect (m).to_equal (l)
    - it serves as a prototype for new instances:
        m = l:clone {}
        expect (objtype (m)).to_be "List"
        expect (m).to_equal (l)
        expect (getmetatable (m)).to_be (getmetatable (l))

  # List {args} is just syntactic sugar for List:clone {args}
  - context from List object prototype:
    - it constructs a new List:
        l = List {}
        expect (l).not_to_be (List)
        expect (objtype (l)).to_be "List"
    - it reuses the List metatable:
        l, m = List {"l"}, List {"m"}
        expect (getmetatable (l)).to_be (getmetatable (m))
    - it initialises List with constructor parameters:
        m = List {"foo", "bar", "baz"}
        expect (m).to_equal (l)
    - it serves as a prototype for new instances:
        m = l {}
        expect (objtype (m)).to_be "List"
        expect (m).to_equal (l)
        expect (getmetatable (m)).to_be (getmetatable (l))


- describe metatable propagation:
  - it reuses the metatable for List constructed objects:
      m = List {"foo", "bar"}
      expect (getmetatable (m)).to_be (getmetatable (l))


- describe append:
  - before:
      f = M.append

  - context with bad arguments:
      badargs.diagnose (f, "std.list.append (List, any)")

  - context as a module function:
    - it returns a List object:
        expect (objtype (f (l, "quux"))).to_be "List"
    - it works for an empty List:
        expect (f (List {}, "quux")).to_equal (List {"quux"})
    - it appends an item to a List:
        expect (f (l, "quux")).
          to_equal (List {"foo", "bar", "baz", "quux"})

  - context as an object method:
    - before:
        f = l.append

    - it returns a List object:
        expect (objtype (f (l, "quux"))).to_be "List"
    - it works for an empty List:
        expect (f (List {}, "quux")).to_equal (List {"quux"})
    - it appends an item to a List:
        expect (f (l, "quux")).
          to_equal (List {"foo", "bar", "baz", "quux"})

  - context as a List metamethod:
    - it returns a List object:
        expect (objtype (l + "quux")).to_be "List"
    - it works for an empty list:
        expect (List {} + "quux").to_equal (List {"quux"})
    - it appends an item to a list:
        expect (l + "quux").
          to_equal (List {"foo", "bar", "baz", "quux"})


- describe compare:
  - before:
      a, b = List {"foo", "bar"}, List {"foo", "baz"}

      f = M.compare

  - context with bad arguments:
      badargs.diagnose (f, "std.list.compare (List, List|table)")

  - context as a module function:
    - it returns -1 when the first list is less than the second:
        expect (f (a, {"foo", "baz"})).to_be (-1)
        expect (f (a, List {"foo", "baz"})).to_be (-1)
    - it returns -1 when the second list has additional elements:
        expect (f (List {"foo"}, {"foo", "bar"})).to_be (-1)
        expect (f (List {"foo"}, List {"foo", "bar"})).to_be (-1)
    - it returns 0 when two lists are the same:
        expect (f (a, {"foo", "bar"})).to_be (0)
        expect (f (a, List {"foo", "bar"})).to_be (0)
    - it returns +1 when the first list is greater than the second:
        expect (f (a, {"baz", "quux"})).to_be (1)
        expect (f (a, List {"baz", "quux"})).to_be (1)
    - it returns +1 when the first list has additional elements:
        expect (f (a, {"foo"})).to_be (1)
        expect (f (a, List {"foo"})).to_be (1)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (f (a, b)).to_be (-1)

  - context as an object method:
    - before:
        f = a.compare

    - it returns -1 when the first list is less than the second:
        expect (f (a, {"foo", "baz"})).to_be (-1)
        expect (f (a, List {"foo", "baz"})).to_be (-1)
    - it returns -1 when the second list has additional elements: |
        b = List {"foo"}
        expect (f (b, {"foo", "bar"})).to_be (-1)
        expect (List {"foo"}:compare (List {"foo", "bar"})).to_be (-1)
    - it returns 0 when two lists are the same:
        expect (f (a, {"foo", "bar"})).to_be (0)
        expect (f (a, List {"foo", "bar"})).to_be (0)
    - it returns +1 when the first list is greater than the second:
        expect (f (a, {"baz", "quux"})).to_be (1)
        expect (f (a, List {"baz", "quux"})).to_be (1)
    - it returns +1 when the first list has additional elements:
        expect (f (a, {"foo"})).to_be (1)
        expect (f (a, List {"foo"})).to_be (1)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (f (a, b)).to_be (-1)

  - context as a '<' List metamethod:
    - it succeeds when the first list is less than the second:
        expect (a < b).to_be (true)
    - it fails when the first list is not less than the second:
        expect (a < a).to_be (false)
        expect (b < a).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a < b).to_be (true)

  - context as a '>' List metamethod:
    - it succeeds when the first list is greater than the second:
        expect (b > a).to_be (true)
    - it fails when the first list is not greater than the second:
        expect (b > b).to_be (false)
        expect (a > b).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a > b).to_be (false)

  - context as a '<=' List metamethod:
    - it succeeds when the first list is less than or equal to the second:
        expect (a <= b).to_be (true)
        expect (a <= a).to_be (true)
    - it fails when the first list is not less than or equal to the second:
        expect (b <= a).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a <= b).to_be (true)

  - context as a '>=' List metamethod:
    - it succeeds when the first list is greater than or equal to the second:
        expect (b >= a).to_be (true)
        expect (b >= b).to_be (true)
    - it fails when the first list is not greater than or equal to the second:
        expect (a >= b).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a >= b).to_be (false)


- describe concat:
  - before:
      l = List {"foo", "bar"}

      f = M.concat

  - context with bad arguments:
      badargs.diagnose (f, "std.list.concat (List, List|table*)")

  - context as a module function:
    - it returns a List object:
        expect (objtype (f (l, l))).to_be "List"
    - it works for an empty List:
        expect (f (List {}, {"baz"})).to_equal (List {"baz"})
        expect (f (List {}, List {"baz"})).to_equal (List {"baz"})
    - it concatenates Lists:
        expect (f (l, {"baz", "quux"})).
          to_equal (List {"foo", "bar", "baz", "quux"})
        expect (f (l, List {"baz", "quux"})).
          to_equal (List {"foo", "bar", "baz", "quux"})
        expect (f (l, {"baz"}, {"quux"})).
          to_equal (List {"foo", "bar", "baz", "quux"})
        expect (f (l, List {"baz"}, List {"quux"})).
          to_equal (List {"foo", "bar", "baz", "quux"})

  - context as an object method:
    - before:
        f = l.concat

    - it returns a List object:
        expect (objtype (f (l, l))).to_be "List"
    - it works for an empty List:
        expect (f (List {}, {"baz"})).to_equal (List {"baz"})
        expect (f (List {}, List {"baz"})).to_equal (List {"baz"})
    - it concatenates Lists:
        expect (f (l, {"baz", "quux"})).
          to_equal (List {"foo", "bar", "baz", "quux"})
        expect (f (l, List {"baz", "quux"})).
          to_equal (List {"foo", "bar", "baz", "quux"})
        expect (f (l, {"baz"}, {"quux"})).
          to_equal (List {"foo", "bar", "baz", "quux"})
        expect (f (l, List {"baz"}, List {"quux"})).
          to_equal (List {"foo", "bar", "baz", "quux"})

  # Beware that .. operations are right associative
  - context as a List metamethod:
    - it returns a List object:
        expect (objtype (l .. List {"baz"})).to_be "List"
    - it works for an empty List:
        expect (List {} .. {"baz"}).to_equal (List {"baz"})
        expect (List {} .. List {"baz"}).to_equal (List {"baz"})
    - it concatenates Lists:
        expect (l .. {"baz", "quux"}).
          to_equal (List {"foo", "bar", "baz", "quux"})
        expect (l .. List {"baz", "quux"}).
          to_equal (List {"foo", "bar", "baz", "quux"})
        expect ({"baz"} .. {"quux"} .. l).
          to_equal (List {"baz", "quux", "foo", "bar"})
        expect (l .. List {"baz"} .. List {"quux"}).
          to_equal (List {"foo", "bar", "baz", "quux"})


- describe cons:
  - before:
      f = M.cons

  - context with bad arguments:
      badargs.diagnose (f, "std.list.cons (List, any)")

  - context as a module function:
    - it returns a List object:
        expect (objtype (f (l, "x"))).to_be "List"
    - it prepends an item to a List:
        expect (f (l, "x")).to_equal (List {"x", "foo", "bar", "baz"})
    - it works for empty Lists:
        expect (f (List {}, "x")).to_equal (List {"x"})

  - context as an object method:
    - before:
        f = l.cons

    - it returns a List object:
        expect (objtype (f (l, "x"))).to_be "List"
    - it prepends an item to a List:
        expect (f (l, "x")).to_equal (List {"x", "foo", "bar", "baz"})
    - it works for empty Lists:
        expect (f (List {}, "x")).to_equal (List {"x"})


- describe rep:
  - before:
      l = List {"foo", "bar"}

      f = M.rep

  - context with bad arguments:
      badargs.diagnose (f, "std.list.rep (List, int)")

  - context as a module function:
    - it returns a List object:
        expect (objtype (f (l, 3))).to_be "List"
    - it works for an empty List:
        expect (f (List {}, 99)).to_equal (List {})
    - it repeats the contents of a List:
        expect (f (l, 3)).
          to_equal (List {"foo", "bar", "foo", "bar", "foo", "bar"})

  - context as an object method:
    - before:
        f = l.rep

    - it returns a List object:
        expect (objtype (f (l, 3))).to_be "List"
    - it works for an empty List:
        expect (f (List {}, 99)).to_equal (List {})
    - it repeats the contents of a List:
        expect (f (l, 3)).
          to_equal (List {"foo", "bar", "foo", "bar", "foo", "bar"})


- describe sub:
  - before:
      l = List {1, 2, 3, 4, 5, 6, 7}

      f = M.sub

  - context with bad arguments:
      badargs.diagnose (f, "std.list.sub (List, ?int, ?int)")

  - context as a module function:
    - it returns a List object:
        expect (objtype (f (l, 1, 1))).to_be "List"
    - it makes a List from a subrange of another List:
        expect (f (l, 2, 5)).to_equal (List {2, 3, 4, 5})
    - it truncates the result if 'to' argument is too large:
        expect (f (l, 5, 10)).to_equal (List {5, 6, 7})
    - it defaults 'to' to the end of the List:
        expect (f (l, 5)).to_equal (List {5, 6, 7})
    - it defaults 'from' to the beginning of the List:
        expect (f (l)).to_equal (l)
    - it returns an empty List when 'from' is greater than 'to':
        expect (f (l, 2, 1)).to_equal (List {})
    - it counts from the end of the List for a negative 'from' argument:
        expect (f (l, -3)).to_equal (List {5, 6, 7})
    - it counts from the end of the List for a negative 'to' argument:
        expect (f (l, -5, -2)).to_equal (List {3, 4, 5, 6})

  - context as an object method:
    - before:
        f = l.sub

    - it returns a List object:
        expect (objtype (f (l, 1, 1))).to_be "List"
    - it makes a List from a subrange of another List:
        expect (f (l, 2, 5)).to_equal (List {2, 3, 4, 5})
    - it truncates the result if 'to' argument is too large:
        expect (f (l, 5, 10)).to_equal (List {5, 6, 7})
    - it defaults 'to' to the end of the List:
        expect (f (l, 5)).to_equal (List {5, 6, 7})
    - it defaults 'from' to the beginning of the List:
        expect (f (l)).to_equal (l)
    - it returns an empty List when 'from' is greater than 'to':
        expect (f (l, 2, 1)).to_equal (List {})
    - it counts from the end of the List for a negative 'from' argument:
        expect (f (l, -3)).to_equal (List {5, 6, 7})
    - it counts from the end of the List for a negative 'to' argument:
        expect (f (l, -5, -2)).to_equal (List {3, 4, 5, 6})


- describe tail:
  - before:
      l = List {1, 2, 3, 4, 5, 6, 7}

      f = M.tail

  - context with bad arguments:
      badargs.diagnose (f, "std.list.tail (List)")

  - context as a module function:
    - it returns a List object:
        expect (objtype (f (l))).to_be "List"
    - it makes a new List with the first element removed:
        expect (f (l)).to_equal (List {2, 3, 4, 5, 6, 7})
    - it works for an empty List:
        expect (f (List {})).to_equal (List {})
    - it returns an empty List when passed a List with one element:
        expect (f (List {1})).to_equal (List {})

  - context as an object method:
    - before:
        f = l.tail

    - it returns a List object:
        expect (objtype (f (l))).to_be "List"
    - it makes a new List with the first element removed:
        expect (f (l)).to_equal (List {2, 3, 4, 5, 6, 7})
    - it works for an empty List:
        expect (f (List {})).to_equal (List {})
    - it returns an empty List when passed a List with one element:
        expect (f (List {1})).to_equal (List {})


- describe __pickle:
  - before:
      loadstring = loadstring or load
      function unpickle (s) return loadstring ("return " .. s) () end
      f = require "std.string".pickle

      Derived = List {_type = "Derived"}
      things = Derived {false, "str", 42}

  - it returns a string:
      expect (type (f (things))).to_be "string"
  - it resets '_module' metafield when '_type' changes:
      expect (getmetatable (things)._module).to_be (nil)
  - it supports setting '_module' and '_type' metafields:
      Everything = Derived { _type = "Everything", _module = "nearly" }
      expect (objtype (Everything)).to_be "Everything"
      expect (getmetatable (Everything)._module).to_be "nearly"
      Everything = List { _type = "Everything", _module = "nearly" }
      expect (objtype (Everything)).to_be "Everything"
      expect (getmetatable (Everything)._module).to_be "nearly"
  - it does not have a period in '_type':
      Period = Derived { _type = "specs.example.Period" }
      expect (string.find (type (Period), "%.")).to_be (nil)
  - it propagates the '_module' metafield when '_type' is unchanged:
      expect (getmetatable (List {1})._module).
        to_be (getmetatable (List)._module)
  - context with '_module' metafield:
    - it requires the module path for later invocation:
        expect (f (List)).to_be 'require "std.list".prototype {}'
    - it roundtrips objects:
        expect (unpickle (f (List))).to_equal (List)
  - context with '_type' metafield only:
    - it uses the '_type' value for later invocation:
        expect (f (things)).to_be 'Derived {[1]=false,[2]="str",[3]=42}'
    - it roundtrips objects:
        compat = require "specl.compat"
        compat.setfenv (unpickle, compat.getfenv (1))
        expect (unpickle (f (things))).to_equal (things)
  - it converts a nested object to a representative string:
      buf = List {Derived {"?"}, ["!"]=42}
      expect (f (buf)).
        to_be 'require "std.list".prototype {[1]=Derived {[1]="?"},["!"]=42}'
  - it roundtrips nested objects:
        buf = List {Derived {"?"}, ["!"]=42}
        expect (unpickle (f (buf))).to_equal (buf)
