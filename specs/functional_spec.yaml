before:
  base = require "std.base"

  this_module  = "std.functional"
  global_table = "_G"

  exported_apis = { "any", "bind", "callable", "case", "collect", "compose",
                    "cond", "curry", "filter", "flatten", "foldl", "foldr",
                    "id", "ireverse", "lambda", "map", "map_with", "memoize",
                    "nop", "product", "reduce", "shape", "zip", "zip_with" }

  setdebug { deprecate = false }

  deprecate_on = bind (deprecation, {"nil", this_module})
  deprecate_off = bind (deprecation, {false, this_module})

  function npairs (t)
    local m = base.getmetamethod (t, "__len")
    local i, n = 0, m and m(t) or base.table.maxn (t)
    return function (t)
      i = i + 1
      if i <= n then return i, t[i] end
     end,
    t, i
  end

  function iter (...)
    local l = pack (...)
    local oob = l.n + 1
    return function (l, n)
      n = n - 1
      if n > 0 then return n, l[n] or false end
    end, l, oob
  end

  M = require (this_module)


specify std.functional:
- context when required:
  - context by name:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by=this_module}).
          to_equal {}
  - it exports the documented apis:
      t = {}
      for k in pairs (M) do t[#t + 1] = k end
      expect (t).to_contain.a_permutation_of (exported_apis)

  - context via the std module:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by="std"}).
          to_equal {}


- describe any:
  - before:
      stop = function () return true end
      fail = function () return false end

      f = M.any

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.any (func*)")

  - it returns a single function:
      expect (type (f (M.id))).to_be "function"
  - it propagates arguments and returned results:
      expect (f (M.id) (true)).to_be (true)
      expect ({f (M.id) (1, 2, 3)}).to_equal {1, 2, 3}
  - it propagates nil arguments correctly:
      truthy = function (x) return x and true or false end
      expect (f (truthy) (true, false, nil, nil, 0, nil)).
        to_equal (true, false, false, false, true, false)
  - it calls all functions until one returns non-nil:
      expect (f (M.id, M.id, stop, fail) (nil)).to_be (true)
  - it only looks at first returned value:
      expect (f (M.id, M.id, stop, fail) (nil, "ignored")).to_be (true)
  - it does not call remaining functions after non-nil return:
      expect (f (M.id, fail) (true)).to_be (true)


- describe bind:
  - before:
      op = require "std.operator"

      f = M.bind

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.bind (function, table)")

  - it does not affect normal operation if no arguments are bound:
      expect (f (math.min, {}) (2, 3, 4)).to_be (2)
  - it takes the extra arguments into account:
      expect (f (math.min, {1, 0}) (2, 3, 4)).to_be (0)
  - it appends final call arguments:
      expect (f (math.max, {2, 3}) (4, 5, 1)).to_be (5)
  - it does not require all arguments in final call:
      div = function (a, b) return a / b end
      expect (f (div, {100}) (25)).to_be (4)
  - it supports out of order extra arguments:
      expect (f (op.pow, {[2] = 3}) (2)).to_be (8)
  - it propagates nil arguments correctly:
      r = pack (f (M.id, {[4]="d"}) (1))
      expect (r).to_equal (pack (1, nil, nil, "d"))
      r = pack (f (M.id, {[4]="d"}) (nil, 2))
      expect (r).to_equal (pack (nil, 2, nil, "d"))
      r = pack (f (M.id, {[2]="b", [4]="d"}) (nil, 3, 5, 6, nil))
      expect (r).to_equal (pack (nil, "b", 3, "d", 5, 6, nil))
      r = pack (f (M.id, {[2]="b", [4]="d"}) (nil, 3, nil, nil, 7))
      expect (r).to_equal (pack (nil, "b", 3, "d", nil, nil, 7))
      r = pack (f (M.id, {[2]="b", [4]="d"}) (nil, 3, nil, nil, 7, nil, nil))
      expect (r).to_equal (pack (nil, "b", 3, "d", nil, nil, 7, nil, nil))


- describe callable:
  - before:
      f = M.callable

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.callable (?any)")

  - it returns the function associated with a callable:
      Container = require "std.container" { __call = M.nop }
      for _, v in ipairs {
        true,
        42,
        "str",
        io.stderr,
        {},
        M.nop,
        setmetatable ({}, {__call = M.nop}),
        Container,
      } do
        expect (f (v)).to_be (pcall (v, {}) and M.nop or nil)
      end
  - it returns 'nil' for uncallable arguments:
      expect (f ()).to_be (nil)
      expect (f {}).to_be (nil)
      expect (f "").to_be (nil)


- describe case:
  - before:
      yes     = function ()  return true end
      no      = function ()  return false end
      default = function (s) return s end
      branches = { yes = yes, no = no, default }

      f = M.case

  - context with bad arguments: |
      badargs.diagnose (f, "std.functional.case (?any, #table)")

  - it matches against branch keys:
      expect (f ("yes", branches)).to_be (true)
      expect (f ("no",  branches)).to_be (false)
  - it has a default for unmatched keys:
      expect (f ("none", branches)).to_be "none"
  - it returns nil for unmatched keys with no default:
      expect (f ("none", { yes = yes, no = no })).to_be (nil)
  - it returns non-function matches:
      expect (f ("t", {t = true})).to_be (true)
  - it evaluates returned functions:
      expect (f ("fn", {fn = function () return true end})).
        to_be (true)
  - it passes 'with' to function matches:
      expect (f ("with", {function (s) return s end})).to_be "with"
  - it evaluates returned functables:
      functable = setmetatable ({}, {__call = function (t, with) return with end})
      expect (f ("functable", {functable})).to_be "functable"
  - it evaluates 'with' exactly once:
      s = "prince"
      function acc () s = s .. "s"; return s end
      expect (f (acc (), {
        prince   = function () return "one" end,
        princes  = function () return "many" end,
        princess = function () return "one" end,
                   function () return "gibberish" end,
      })).to_be "many"


- describe collect:
  - before:
      f = M.collect

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.collect ([func], ?any*)")

  - it collects a list of single return value iterator results:
      expect (f (base.ielems, {"a", "b", "c"})).to_equal {"a", "b", "c"}
  - it collects a table of key:value iterator results:
      t = {"first", second="two", last=3}
      expect (f (pairs, t)).to_equal (t)
  - it defaults to npairs iteration:
      expect (f {1, 2, [5]=5, a="b", c="d"}).to_equal {1, 2, [5]=5}
  - it propagates nil arguments correctly:
      expect (f {"a", nil, nil, "d", "e"}).to_equal {"a", [4]="d", [5]="e"}
      expect (f (iter, "a", nil, nil, "d", "e")).
        to_equal {"a", false, false, "d", "e"}
      expect (f (iter, nil, nil, 3, 4, nil, nil)).
        to_equal {false, false, 3, 4, false, false}


- describe compose:
  - before:
      f = M.compose

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.compose (func*)")

  - it composes a single function correctly:
      expect (f (M.id) (1)).to_be (1)
  - it propagates nil arguments correctly:
      expect (pack (f (M.id) (nil, 2, nil, nil))).
        to_equal (pack (nil, 2, nil, nil))
      expect (pack (f (M.id, M.id) (nil, 2, nil, nil))).
        to_equal (pack (nil, 2, nil, nil))
  - it composes functions in the correct order:
      expect (f (math.sin, math.cos) (1)).
        to_be (math.cos (math.sin (1)))


- describe cond:
  - before:
      yes     = function ()  return true end
      no      = function ()  return false end
      default = function (s) return s end
      branches = { yes = yes, no = no, default }

      f = M.cond

  - it returns nil for no arguments:
      expect (f ()).to_be (nil)
  - it evaluates a single function argument:
      expect (f (function () return true end)).to_be (true)
  - it evaluates a single functable argument:
      functable = setmetatable ({}, {__call = function () return true end})
      expect (f (functable)).to_be (true)
  - it returns a non-callable single argument directly:
      expect (f "foo").to_be "foo"
  - it evaluates a branch function if expr is truthy:
      expect (f ("truthy", function (s) return s end)).to_be "truthy"
  - it returns nil if the last expr is falsey:
      expect (f (nil, function (s) return "falsey" end)).to_be (nil)
      expect (f (false, true, false, true)).to_be (nil)
  - it recurses with remaining arguments if first argument is falsey:
      expect (f (nil, true, 42, M.id)).to_be (42)
      expect (f (nil, true, false, false, 42, M.id)).to_be (42)


- describe curry:
  - before:
      op = require "std.operator"

      f = M.curry

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.curry (func, int)")

  - it returns a zero argument function uncurried:
      expect (f (f, 0)).to_be (f)
  - it returns a one argument function uncurried:
      expect (f (f, 1)).to_be (f)
  - it curries a two argument function:
      expect (f (f, 2)).not_to_be (f)
  - it evaluates intermediate arguments one at a time:
      expect (f (math.min, 3) (2) (3) (4)).to_equal (2)
  - it returns a curried function that can be partially applied:
      bin = f (op.pow, 2) (2)
      expect (bin (2)).to_be (op.pow (2, 2))
      expect (bin (10)).to_be (op.pow (2, 10))


- describe filter:
  - before:
     elements = {"a", "b", "c", "d", "e"}
     inverse  = {a=1, b=2, c=3, d=4, e=5}

     f = M.filter

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.filter (func, [func], any*)")

  - it works with an empty table:
      expect (f (M.id, pairs, {})).to_equal {}
  - it iterates through element keys:
      expect (f (M.id, base.ielems, elements)).to_equal {"a", "b", "c", "d", "e"}
      expect (f (M.id, base.elems, inverse)).to_contain.a_permutation_of {1, 2, 3, 4, 5}
  - it propagates nil arguments correctly:
      t = {"a", nil, nil, "d", "e"}
      expect (f (M.id, npairs, t)).to_equal (t)
      expect (f (M.id, iter, nil, nil, 3, 4, nil, nil)).
        to_equal {false, false, 3, 4, false, false}
  - it passes all iteration result values to filter predicate:
      t = {}
      f (function (k, v) t[k] = v end, pairs, elements)
      expect (t).to_equal (elements)
  - it returns a list of filtered single return value iterator results:
      expect (f (function (e) return e:match "[aeiou]" end, base.ielems, elements)).
        to_equal {"a", "e"}
  - it returns a table of filtered key:value iterator results:
      t = {"first", second=2, last="three"}
      expect (f (function (k, v) return type (v) == "string" end, pairs, t)).
        to_equal {"first", last="three"}
      expect (f (function (k, v) return k % 2 == 0 end, ipairs, elements)).
        to_equal {[2]="b", [4]="d"}
  - it defaults to pairs iteration:
      t = {"first", second=2, last="three"}
      expect (f (function (k, v) return type (v) == "string" end, t)).
        to_equal {"first", last="three"}


- describe flatten:
  - before:
      t = {{{"one"}}, "two", {{"three"}, "four"}}

      f = M.flatten

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.flatten (table)")

  - it returns a table:
      expect (type (f (t))).to_be "table"
  - it works for an empty table:
      expect (f {}).to_equal {}
  - it flattens a nested table:
      expect (f (t)).to_equal {"one", "two", "three", "four"}


- describe foldl:
  - before:
      op = require "std.operator"
      f = M.foldl

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.foldl (func, [any], table)")

  - it works with an empty table:
      expect (f (op.sum, 10000, {})).to_be (10000)
  - it folds a binary function through a table:
      expect (f (op.sum, 10000, {1, 10, 100})).to_be (10111)
  - it folds from left to right:
      expect (f (op.pow, 2, {3, 4})).to_be ((2 ^ 3) ^ 4)
  - it supports eliding init argument:
      expect (f (op.pow, {2, 3, 4})).to_be ((2 ^ 3) ^ 4)


- describe foldr:
  - before:
      op = require "std.operator"
      f = M.foldr

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.foldr (func, [any], table)")

  - it works with an empty table:
      expect (f (op.sum, 1, {})).to_be (1)
  - it folds a binary function through a table:
      expect (f (op.sum, {10000, 100, 10, 1})).to_be (10111)
  - it folds from right to left:
      expect (f (op.quot, 10, {10000, 100})).to_be (10000 / (100 / 10))
  - it supports eliding init argument:
      expect (f (op.quot, {10000, 100, 10})).to_be (10000 / (100 / 10))


- describe id:
  - before:
      f = M.id
  - it returns argument unchanged:
      expect (f (true)).to_be (true)
      expect (f {1, 1, 2, 3}).to_equal {1, 1, 2, 3}
  - it returns multiple arguments unchanged:
      expect ({f (1, "two", false)}).to_equal {1, "two", false}
  - it propagates nil values correctly:
      expect (pack (f ("a", nil, nil, "d", "e"))).
        to_equal (pack ("a", nil, nil, "d", "e"))
      expect (pack (f (nil, nil, 3, 4, nil, nil))).
        to_equal (pack (nil, nil, 3, 4, nil, nil))


- describe ireverse:
  - before: |
      __index = setmetatable ({ content = "a string" }, {
          __index = function (t, n)
                      if n <= #t.content then
                        return t.content:sub (n, n)
                      end
                    end,
          __len   = function (t) return #t.content end,
      })

      f = M.ireverse

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.ireverse (table)")

  - it returns a new list:
      t = {1, 2, 5}
      expect (f (t)).not_to_be (t)
  - it reverses the elements relative to the original list:
      expect (f {1, 2, "five"}).to_equal {"five", 2, 1}
  - it ignores the dictionary part of a table:
      expect (f {1, 2, "five"; a = "b", c = "d"}).to_equal {"five", 2, 1}
  - it respects __len metamethod:
      expect (f (__index)).to_equal {"g", "n", "i", "r", "t", "s", " ", "a"}
  - it works for an empty list:
      expect (f {}).to_equal {}


- describe lambda:
  - before:
      f = M.lambda

      callable = function (x)
        if M.callable (x) then return true end
        return false
      end

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.lambda (string)")

      examples {["it diagnoses bad lambda string"] = function ()
        expect (select (2, f "foo")).to_be "invalid lambda string 'foo'"
      end}
      examples {["it diagnoses an uncompilable expression"] = function ()
        expect (select (2, f "||+")).to_be "invalid lambda string '||+'"
        expect (select (2, f "=")).to_be "invalid lambda string '='"
      end}

  - it returns previously compiled lambdas:
      fn = f "|a,b|a==b"
      expect (fn).to_be (f "|a,b|a==b")

  - context with argument format:
    - it returns a callable:
        expect (callable (f "|x| 1+x")).to_be (true)
    - it compiles to a working Lua function:
        fn = f "||42"
        expect (fn ()).to_be (42)
    - it propagates argument values:
        fn = f "|...| {...}"
        expect (fn (1,2,3)).to_equal {1,2,3}
    - it can be stringified:
        exp = "|a,b|a==b"
        expect (tostring (f (exp))).to_be (exp)
  - context with expression format:
    - it returns a function:
        expect (callable (f "_")).to_be (true)
    - it compiles to a working Lua function:
        fn = f "=42"
        expect (fn ()).to_be (42)
    - it sets auto-argument values:
        fn = f "_*_"
        expect (fn (42)).to_be (1764)
    - it sets numeric auto-argument values:
        fn = f "_1+_2+_3"
        expect (fn (1, 2, 5)).to_be (8)
    - it can be stringified:
        exp = "_%2==0"
        expect (tostring (f (exp))).to_be (exp)


- describe map:
  - before:
      elements = {"a", "b", "c", "d", "e"}
      inverse  = {a=1, b=2, c=3, d=4, e=5}

      f = M.map

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.map (func, [func], ?any*)")

  - it works with an empty table:
      expect (f (M.id, ipairs, {})).to_equal {}
  - it iterates through elements:
      expect (f (M.id, ipairs, elements)).to_equal (elements)
      expect (f (M.id, pairs, inverse)).to_contain.a_permutation_of (elements)
  - it propagates nil arguments correctly:
      t = {"a", nil, nil, "d", "e"}
      expect (f (M.id, npairs, t)).to_equal (t)
      expect (f (M.id, iter, nil, nil, 3, 4, nil, nil)).
        to_equal {false, false, 3, 4, false, false}
  - it passes all iteration result values to map function:
      t = {}
      f (function (k, v) t[k] = v end, pairs, elements)
      expect (t).to_equal (elements)
  - it returns a list of mapped single return value iterator results:
      expect (f (function (e) return e:match "[aeiou]" end, base.ielems, elements)).
        to_equal {"a", "e"}
      expect (f (function (e) return e .. "x" end, base.elems, elements)).
        to_contain.a_permutation_of {"ax", "bx", "cx", "dx", "ex"}
  - it returns a table of mapped key:value iterator results:
      t = {"first", second=2, last="three"}
      expect (f (function (k, v) return type (v) == "string" end, pairs, t)).
        to_contain.a_permutation_of {true, false, true}
      expect (f (function (k, v) return k % 2 == 0 end, ipairs, elements)).
        to_equal {false, true, false, true, false}
  - it supports key:value results from mapping function:
      expect (f (function (k, v) return v, k end, pairs, elements)).
        to_equal (inverse)
  - it defaults to pairs iteration:
      t = {"first", second=2, last="three"}
      expect (f (function (k, v) return type (v) == "string" end, t)).
        to_contain.a_permutation_of {true, false, true}


- describe map_with:
  - before:
      t = {{1, 2, 3}, {4, 5}}
      fn = function (...) return select ("#", ...) end

      f = M.map_with

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.map_with (func, table of tables)")

  - it works for an empty table:
      expect (f (fn, {})).to_equal ({})
  - it returns a table:
      u = f (fn, t)
      expect (type (u)).to_be "table"
  - it creates a new table:
      old = t
      u = f (fn, t)
      expect (t).to_equal (old)
      expect (u).not_to_equal (old)
      expect (t).to_equal {{1, 2, 3}, {4, 5}}
  - it maps a function over a list of argument lists:
      expect (f (fn, t)).to_equal {3, 2}
  - it discards hash-part arguments:
      expect (f (fn, {{1,x=2,3}, {4,5,y="z"}})).to_equal {2, 2}
  - it maps a function over a table of argument lists:
      expect (f (fn, {a={1,2,3}, b={4,5}})).to_equal {a=3, b=2}


- describe memoize:
  - before:
      f = M.memoize

      memfn = f (function (...)
                   n = select ("#", ...)
                   if n == 0 then return nil, "bzzt" end
                   return n, {...}
                 end)

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.memoize (func, ?func)")

  - it propagates multiple return values:
      expect ((memfn ())).to_be (nil)
      expect (select (2, memfn ())).to_be "bzzt"
  - it propogates nil return values:
      expect (pack (f (function (...) return ... end) (nil, nil, 3, 4, nil, nil))).
        to_equal (pack (nil, nil, 3, 4, nil, nil))
  - it propagates multiple arguments:
      expect ({memfn ("a", 42, false)}).to_equal {3, {"a", 42, false}}
  - it propagates nil arguments:
      n, t = memfn (nil)
      expect (t).to_equal ({})
      expect ({memfn (nil, 2, nil, nil)}).to_equal {4, {[2]=2}}
  - it returns the same results for the same arguments:
      n, t = memfn (1)
      n, u = memfn (1)
      expect (t).to_be (u)
  - it returns a different object for different arguments:
      n, t = memfn (1)
      n, u = memfn (1, 2)
      expect (t).not_to_be (u)
  - it returns the same object for table valued arguments:
      n, t = memfn {1, 2, 3}
      n, u = memfn {1, 2, 3}
      expect (t).to_be (u)
      n, t = memfn {foo = "bar", baz = "quux"}
      n, u = memfn {foo = "bar", baz = "quux"}
      expect (t).to_be (u)
      n, t = memfn {baz = "quux", foo = "bar"}
      expect (t).to_be (u)
  - it returns a different object for different table arguments:
      n, t = memfn {1, 2, 3}
      n, u = memfn {1, 2}
      expect (t).not_to_be (u)
      n, u = memfn {3, 1, 2}
      expect (t).not_to_be (u)
      n, u = memfn {1, 2, 3, 4}
      expect (t).not_to_be (u)
  - it returns a different object for additional trailing nils:
      n, t = memfn (1, nil)
      n, u = memfn (1)
      expect (t).not_to_be (u)
      n, u = memfn (1, nil, nil)
      expect (t).not_to_be (u)
  - it accepts alternative mnemonic function:
      mnemonic = function (...) return select ("#", ...) end
      memfn = f (function (x) return {x} end, mnemonic)
      expect (memfn "same").to_be (memfn "not same")
      expect (memfn (1, 2)).to_be (memfn (false, "x"))
      expect (memfn "one").not_to_be (memfn ("one", "two"))


- describe nop:
  - before:
      f = M.nop
  - it accepts any number of arguments:
      expect (f ()).to_be (nil)
      expect (f (false)).to_be (nil)
      expect (f (1, 2, 3, nil, "str", {}, f)).to_be (nil)
  - it returns no values:
      expect (f (1, "two", false)).to_be (nil)


- describe product:
  - before:
      f = M.product

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.product (list*)")

  - it works with an empty table:
      expect (f {}).to_equal {}
  - it returns a list of elements from a single argument:
      expect (f {'a', 'b', 'c'}).to_equal {{'a'}, {'b'}, {'c'}}
  - it lists combinations with one element from each argument:
      expect (f ({1, 2, 3}, {4, 5, 6})).to_equal {
        {1, 4}, {1, 5}, {1, 6},
        {2, 4}, {2, 5}, {2, 6},
        {3, 4}, {3, 5}, {3, 6},
      }
      expect (f ({1, 2}, {3, 4}, {5, 6})).to_equal {
        {1, 3, 5}, {1, 3, 6},  {1, 4, 5}, {1, 4, 6},
        {2, 3, 5}, {2, 3, 6},  {2, 4, 5}, {2, 4, 6},
      }
      expect (M.map (table.concat, base.ielems, f ({0,1},{0,1},{0,1}))).
        to_equal {"000", "001", "010", "011", "100", "101", "110", "111"}


- describe reduce:
  - before:
      op = require "std.operator"

      f = M.reduce

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.reduce (func, any, [func], ?any*)")

  - it works with an empty table:
      expect (f (op.sum, 2, ipairs, {})).to_be (2)
  - it calls a binary function over single return value iterator results:
      expect (f (op.sum, 2, base.ielems, {3})).
        to_be (2 + 3)
      expect (f (op.prod, 2, base.ielems, {3, 4})).
        to_be (2 * 3 * 4)
  - it calls a binary function over key:value iterator results:
      expect (f (op.sum, 2, base.ielems, {3})).to_be (2 + 3)
      expect (f (op.prod, 2, base.ielems, {3, 4})).to_be (2 * 3 * 4)
  - it propagates nil arguments correctly:
      function set (t, k, v) t[k] = tostring (v) return t end
      expect (f (set, {}, npairs, {1, nil, nil, "a", false})).
        to_equal {"1", "nil", "nil", "a", "false"}
      expect (f (set, {}, npairs, {nil, nil, "3"})).
        to_equal {"nil", "nil", "3"}
      expect (f (set, {}, iter, nil, nil, 3, 4, nil, nil)).
        to_equal {"false", "false", "3", "4", "false", "false"}
  - it reduces elements from left to right:
      expect (f (op.pow, 2, base.ielems, {3, 4})).to_be ((2 ^ 3) ^ 4)
  - it passes all iterator results to accumulator function:
      expect (f (rawset, {}, {"one", two=5})).to_equal {"one", two=5}


- describe shape:
  - before:
      l = {1, 2, 3, 4, 5, 6}

      f = M.shape

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.shape (table, table)")

  - it returns a table:
      expect (objtype (f ({2, 3}, l))).to_be "table"
  - it works for an empty table:
      expect (f ({0}, {})).to_equal ({})
  - it returns the result in a new table:
      expect (f ({2, 3}, l)).not_to_be (l)
  - it does not perturb the argument table:
      f ({2, 3}, l)
      expect (l).to_equal {1, 2, 3, 4, 5, 6}
  - it reshapes a table according to given dimensions:
      expect (f ({2, 3}, l)).
        to_equal ({{1, 2, 3}, {4, 5, 6}})
      expect (f ({3, 2}, l)).
        to_equal ({{1, 2}, {3, 4}, {5, 6}})
  - it treats 0-valued dimensions as an indefinite number:
      expect (f ({2, 0}, l)).
        to_equal ({{1, 2, 3}, {4, 5, 6}})
      expect (f ({0, 2}, l)).
        to_equal ({{1, 2}, {3, 4}, {5, 6}})


- describe zip:
  - before:
      tt = {{1, 2}, {3, 4}, {5, 6}}

      f = M.zip

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.zip (table)")

  - it works for an empty table:
      expect (f {}).to_equal {}
  - it is the inverse of itself:
      expect (f (f (tt))).to_equal (tt)
  - it transposes rows and columns:
      expect (f (tt)).to_equal {{1, 3, 5}, {2, 4, 6}}
      expect (f {x={a=1, b=2}, y={a=3, b=4}, z={b=5}}).
        to_equal {a={x=1, y=3}, b={x=2,y=4,z=5}}


- describe zip_with:
  - before:
      tt = {{1, 2}, {3, 4}, {5}}
      fn = function (...) return tonumber (table.concat {...}) end

      f = M.zip_with

  - context with bad arguments:
      badargs.diagnose (f, "std.functional.zip_with (function, table of tables)")

  - it works for an empty table:
      expect (f (fn, {})).to_equal {}
  - it returns a table:
      expect (type (f (fn, tt))).to_be "table"
  - it returns the result in a new table:
      expect (f (fn, tt)).not_to_be (tt)
  - it does not perturb the argument list:
      m = f (fn, tt)
      expect (tt).to_equal {{1, 2}, {3, 4}, {5}}
  - it combines column entries with a function:
      expect (f (fn, tt)).to_equal {135, 24}
  - it discards hash-part arguments:
      expect (f (fn, {{1,2}, x={3,4}, {[2]=5}})).to_equal {1, 25}
  - it combines matching key entries with a function:
      expect (f (fn, {{a=1,b=2}, {a=3,b=4}, {b=5}})).
        to_equal {a=13, b=245}
